// Generated by go-postgres-codegen 1
package persistence

import (
	"context"
	"fmt"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const AccessConstraintsInsertSql = `
	INSERT INTO 
		public.access_constraints
	(
		id,
		idear,
		operator_id,
		property_id,
		property_value
	)
	VALUES
		($1,$2,$3,$4,$5)
`

const AccessConstraintsUpdateSql = `
	UPDATE 
		public.access_constraints
	SET
		id=$1,
		idear=$2,
		operator_id=$3,
		property_id=$4,
		property_value=$5
	WHERE
		id=$6
`

const AccessConstraintsDeleteSql = `
	DELETE FROM
		public.access_constraints
	WHERE
		id=$1
`

type AccessConstraints struct {
	Id            pgtype.UUID `db:"id"`
	Idear         pgtype.UUID `db:"idear"`
	OperatorId    int32       `db:"operator_id"`
	PropertyId    int64       `db:"property_id"`
	PropertyValue float64     `db:"property_value"`
}

func (self *AccessConstraints) InsertTx(tx *pgx.Tx) (int64, error) {
	commandTag, err := (*tx).Exec(context.Background(), AccessConstraintsInsertSql,
		self.Id,
		self.Idear,
		self.OperatorId,
		self.PropertyId,
		self.PropertyValue,
	)

	return commandTag.RowsAffected(), err
}

func BatchInsertAccessConstraints(tx *pgx.Tx, batch *[]AccessConstraints) (int64, error) {
	vals := []interface{}{}
	stmt := `
	INSERT INTO 
		public.access_constraints
	(
		id,
		idear,
		operator_id,
		property_id,
		property_value
	)
	VALUES `
	c := 0
	for i, item := range *batch {
		stmt = stmt + fmt.Sprintf(`($%d,$%d,$%d,$%d,$%d)`, c+1, c+2, c+3, c+4, c+5)
		if i < len(*batch)-1 {
			stmt = stmt + ","
		}
		vals = append(vals, item.Id, item.Idear, item.OperatorId, item.PropertyId, item.PropertyValue)
		c = c + 5
	}

	commandTag, err := (*tx).Exec(context.Background(), stmt, vals...)

	return commandTag.RowsAffected(), err
}

func StrBatchInsertAccessConstraints(batchSize int) string {
	stmt := `
	INSERT INTO 
		public.access_constraints
	(
		id,
		idear,
		operator_id,
		property_id,
		property_value
	)
	VALUES `
	c := 0
	for i := 0; i < batchSize; i++ {
		stmt = stmt + fmt.Sprintf(`($%d,$%d,$%d,$%d,$%d)`, c+1, c+2, c+3, c+4, c+5)
		if i < batchSize-1 {
			stmt = stmt + ","
		}
		c = c + 5
	}
	return stmt
}

func (self *AccessConstraints) UpdateTx(tx *pgx.Tx) (int64, error) {
	commandTag, err := (*tx).Exec(context.Background(), AccessConstraintsUpdateSql,
		self.Id,
		self.Idear,
		self.OperatorId,
		self.PropertyId,
		self.PropertyValue,
		self.Id,
	)

	return commandTag.RowsAffected(), err
}

func (self *AccessConstraints) DeleteTx(tx *pgx.Tx) (int64, error) {
	commandTag, err := (*tx).Exec(context.Background(), AccessConstraintsDeleteSql, self.Id)

	return commandTag.RowsAffected(), err
}

func (self *AccessConstraints) Scan(rows *pgx.Rows, extensions ...PersistenceExtension) {
	vals, _ := (*rows).Values()
	for i, f := range (*rows).FieldDescriptions() {
		val := vals[i]
		switch string(f.Name) {
		case "id":

			temp := val.([16]uint8)
			uuidVal := pgtype.UUID{}
			uuidVal.Set(temp)
			self.Id = uuidVal

		case "idear":

			temp := val.([16]uint8)
			uuidVal := pgtype.UUID{}
			uuidVal.Set(temp)
			self.Idear = uuidVal

		case "operator_id":
			self.OperatorId = val.(int32)
		case "property_id":
			self.PropertyId = val.(int64)
		case "property_value":
			self.PropertyValue = val.(float64)
		default:
			for _, extension := range extensions {
				extension.Extend(string(f.Name), val)
			}
		}
	}
}
