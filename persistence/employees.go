// Generated by go-postgres-codegen 1
package persistence

import (
	"context"
	"fmt"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const EmployeesInsertSql = `
	INSERT INTO 
		public.employees
	(
		id,
		firstname,
		lastname,
		idc,
		c,
		r,
		u,
		d
	)
	VALUES
		($1,$2,$3,$4,$5,$6,$7,$8)
`

const EmployeesUpdateSql = `
	UPDATE 
		public.employees
	SET
		id=$1,
		firstname=$2,
		lastname=$3,
		idc=$4,
		c=$5,
		r=$6,
		u=$7,
		d=$8
	WHERE
		id=$9
`

const EmployeesDeleteSql = `
	DELETE FROM
		public.employees
	WHERE
		id=$1
`

type Employees struct {
	Id        pgtype.UUID `db:"id"`
	Firstname string      `db:"firstname"`
	Lastname  string      `db:"lastname"`
	Idc       pgtype.UUID `db:"idc"`
	C         bool        `db:"c"`
	R         bool        `db:"r"`
	U         bool        `db:"u"`
	D         bool        `db:"d"`
}

func (self *Employees) InsertTx(tx *pgx.Tx) (int64, error) {
	commandTag, err := (*tx).Exec(context.Background(), EmployeesInsertSql,
		self.Id,
		self.Firstname,
		self.Lastname,
		self.Idc,
		self.C,
		self.R,
		self.U,
		self.D,
	)

	return commandTag.RowsAffected(), err
}

func BatchInsertEmployees(tx *pgx.Tx, batch *[]Employees) (int64, error) {
	vals := []interface{}{}
	stmt := `
	INSERT INTO 
		public.employees
	(
		id,
		firstname,
		lastname,
		idc,
		c,
		r,
		u,
		d
	)
	VALUES `
	c := 0
	for i, item := range *batch {
		stmt = stmt + fmt.Sprintf(`($%d,$%d,$%d,$%d,$%d,$%d,$%d,$%d)`, c+1, c+2, c+3, c+4, c+5, c+6, c+7, c+8)
		if i < len(*batch)-1 {
			stmt = stmt + ","
		}
		vals = append(vals, item.Id, item.Firstname, item.Lastname, item.Idc, item.C, item.R, item.U, item.D)
		c = c + 8
	}

	commandTag, err := (*tx).Exec(context.Background(), stmt, vals...)

	return commandTag.RowsAffected(), err
}

func StrBatchInsertEmployees(batchSize int) string {
	stmt := `
	INSERT INTO 
		public.employees
	(
		id,
		firstname,
		lastname,
		idc,
		c,
		r,
		u,
		d
	)
	VALUES `
	c := 0
	for i := 0; i < batchSize; i++ {
		stmt = stmt + fmt.Sprintf(`($%d,$%d,$%d,$%d,$%d,$%d,$%d,$%d)`, c+1, c+2, c+3, c+4, c+5, c+6, c+7, c+8)
		if i < batchSize-1 {
			stmt = stmt + ","
		}
		c = c + 8
	}
	return stmt
}

func (self *Employees) UpdateTx(tx *pgx.Tx) (int64, error) {
	commandTag, err := (*tx).Exec(context.Background(), EmployeesUpdateSql,
		self.Id,
		self.Firstname,
		self.Lastname,
		self.Idc,
		self.C,
		self.R,
		self.U,
		self.D,
		self.Id,
	)

	return commandTag.RowsAffected(), err
}

func (self *Employees) DeleteTx(tx *pgx.Tx) (int64, error) {
	commandTag, err := (*tx).Exec(context.Background(), EmployeesDeleteSql, self.Id)

	return commandTag.RowsAffected(), err
}

func (self *Employees) Scan(rows *pgx.Rows, extensions ...PersistenceExtension) {
	vals, _ := (*rows).Values()
	for i, f := range (*rows).FieldDescriptions() {
		val := vals[i]
		switch string(f.Name) {
		case "id":

			temp := val.([16]uint8)
			uuidVal := pgtype.UUID{}
			uuidVal.Set(temp)
			self.Id = uuidVal

		case "firstname":
			self.Firstname = val.(string)
		case "lastname":
			self.Lastname = val.(string)
		case "idc":

			temp := val.([16]uint8)
			uuidVal := pgtype.UUID{}
			uuidVal.Set(temp)
			self.Idc = uuidVal

		case "c":
			self.C = val.(bool)
		case "r":
			self.R = val.(bool)
		case "u":
			self.U = val.(bool)
		case "d":
			self.D = val.(bool)
		default:
			for _, extension := range extensions {
				extension.Extend(string(f.Name), val)
			}
		}
	}
}
